# -*- coding: utf-8 -*-
from __future__ import division
from __future__ import unicode_literals

import base64
import hashlib
import hmac
import json
import logging
import requests

from requests.auth import AuthBase
from requests.compat import urlparse

from .request_generators import PagedRequestGenerator, RequestGenerator, SessionRequestGenerator
from .utils import remove_trailing_slash


logger = logging.getLogger(__name__)


# TODO: now mis-named, should not be ICE-specific
ICE_REQUEST_TIMEOUT = (10, 10)  # request and read timeout, respectively, in seconds
# ICE's current automatic limit on results returned in the absence of a specific requested page size
DEFAULT_RESULT_LIMIT = 15
DEFAULT_PAGE_NUMBER = 1
RESULT_LIMIT_PARAMETER = 'limit'
_JSON_CONTENT_TYPE_HEADER = {'Content-Type': 'application/json; charset=utf8'}


class HmacAuth(AuthBase):
    """
    Implements Hash-based Message Authentication Codes (HMAC). HMAC guarantees that: A) a message
    has been generated by a holder of the secret key, and B) that its contents haven't been
    altered since the auth code was generated.
    Instances of HmacAuth are immutable and are therefore safe to use in multiple threads.
    :param username the username of the ice user who ICE activity will be attributed to.
    Overrides the value provided by user_auth if both are present. At least one is required.
    :raises ValueError if no user email address is provided.
    """
    KEYSTORE = {}

    @classmethod
    def deregister_key(cls, key_id):
        del cls.KEYSTORE[key_id]

    @classmethod
    def register_key(cls, key_id, secret_key):
        cls.KEYSTORE[key_id] = secret_key

    def __init__(self, request_generator, key_id, username=None, ):
        """
        :param request_generator: the request generator (object conforming to Requests API) to use
        :param key_id:
        :param username:
        :return:
        """
        secret_key = self.KEYSTORE.get(key_id, None)
        if not secret_key:
            raise ValueError("A secret key is required input for HMAC authentication")
        self._KEY_ID = key_id
        self._USERNAME = username
        self._SECRET_KEY = secret_key

        if not request_generator:
            request_generator = RequestGenerator(auth=self)
        else:
            request_generator.auth = self
        self._request_generator = request_generator

    @property
    def request_generator(self):
        """
        Get the request generator responsible for creating all requests to the remote server.
        """
        return self._request_generator

    def __call__(self, request):
        """
        Overrides the empty base implementation to provide authentication for the provided request
        object.
        """

        # generate a signature for the message by hashing the request using the secret key
        sig = self._build_signature(request)

        # add message headers including the username (if present) and message
        # The version 1 spec of the HmacSignature class calls for the Authorization HTTP header
        #   of the form: {Version}:{KeyId}:{UserId}:{Signature}
        header = ':'.join(('1', self._KEY_ID, self._USERNAME, sig))
        request.headers['Authorization'] = header
        return request

    def _build_message(self, request):
        """
        Builds a string representation of the message contained in the request so it can be digested
        for HMAC generation
        """
        url = urlparse(request.url)

        # THe version 1 spec of the HmacSignature class calls for the message to be signed
        #   formatted as the following elements, each separated by a newline character:
        #   * UserId (same value as used in Authorization header)
        #   * HTTP Method (e.g. GET, POST)
        #   * HTTP Host (e.g. server.example.org)
        #   * Request path (e.g. /path/to/resource/)
        #   * SORTED query string, keyed by natural UTF8 byte-ordering of names
        #   * Request Body
        delimiter = '\n'
        msg = delimiter.join((
            self._USERNAME or '',
            request.method,
            url.netloc,
            url.path,
            self._sort_parameters(url.query),
            request.body or '',
        ))
        return msg

    def _build_signature(self, request):
        """
        Builds a signature for the provided request message based on the secret key.
        """
        key = base64.b64decode(self._SECRET_KEY)
        msg = self._build_message(request)
        digest = hmac.new(key, msg=msg, digestmod=hashlib.sha1).digest()
        sig = base64.b64encode(digest).decode()
        return sig

    def _sort_parameters(self, query):
        params = sorted(map(lambda p: p.split('=', 1), query.split('&')), key=lambda p: p[0])
        return '&'.join(map(lambda p: '='.join(p), params))

    ############################################
    # 'with' context manager implementation ###
    ############################################
    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        pass
    ############################################


class SessionAuth(AuthBase):
    """
    Implements session-based authentication for ICE. At the time of initial implementation,
    "session-based" is a bit misleading for the processing performed here, since ICE's login
    mechanism doesn't reply with set-cookie headers or read the session ID in the session cookie.
    Instead, ICE's REST API responds to a successful login with a JSON object containing the session
    ID, and authenticates subsequent requests by requiring the session ID in each subsequent
    request header.

    Clients should first call login() to get a valid ice session id
    """
    def __init__(self, session_id, session, timeout=ICE_REQUEST_TIMEOUT, verify_ssl_cert=True):
        self._session_id = session_id
        self._session = session

        session_request_generator = SessionRequestGenerator(session, auth=self, timeout=timeout,
                                                            verify_ssl_cert=verify_ssl_cert)

        paging_request_generator = PagedRequestGenerator(
            request_api=session_request_generator,
            result_limit_param_name=RESULT_LIMIT_PARAMETER,
            result_limit=DEFAULT_RESULT_LIMIT)

        self._request_generator = paging_request_generator

    @property
    def request_generator(self):
        """
        Get the request generator responsible for creating all requests to the remote server.
        """
        return self._request_generator

    def __call__(self, request):
        """
        Overrides the empty base implementation to provide authentication for the provided request
        object (which should normally be _session). ICE doesn't seem to read the session ID from
        cookies, so there's no specific need to provide those here.
        """
        request.headers['X-ICE-Authentication-SessionId'] = self._session_id
        return request

    ############################################
    # 'with' context manager implementation ###
    ############################################
    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self._session.__exit__(type, value, traceback)
    ############################################

    @staticmethod
    def login(base_url, username, password, user_auth=None, timeout=ICE_REQUEST_TIMEOUT,
              verify_ssl_cert=True):
        """
        Logs into ICE at the provided base URL or raises an Exception if an unexpected response is
        received from the server.
        :param base_url: the base URL of the ICE installation (not including the protocol
        :param timeout a tuple representing the connection and read timeouts, respectively, in
        seconds, for the login request to ICE's REST API
        :param verify_ssl_cert True to verify ICE's SSL certificate. Provided so clients can ignore
        self-signed certificates during *local* EDD / ICE testing on a single development machine.
        Note that it's very dangerous to skip certificate verification when communicating across
        the network, and this should NEVER be done in production.
        :return: new SessionAuth containing the newly-created session. Note that at present the
        session isn't strictly required, but is provided for completeness in case ICE's
        behavior changes to store the session ID as a cookie instead of requiring it as a request
        header.
        """

        if not username:
            username = user_auth.email if user_auth else None

        if not username:
            raise ValueError("At least one source of ICE username is required")

        # chop off the trailing '/', if any, so we can write easier-to-read URL snippets in our code
        # (starting w '%s/'). also makes our code trailing-slash agnostic.
        base_url = remove_trailing_slash(base_url)

        # begin a session to track any persistent state required by the server
        session = requests.session()

        # build request parameters for login
        login_dict = {'email': username,
                      'password': password}
        login_resource_url = '%(base_url)s/rest/accesstokens/' % {'base_url': base_url}

        # issue a POST to request login from the ICE REST API
        response = session.post(login_resource_url, headers=_JSON_CONTENT_TYPE_HEADER,
                                data=json.dumps(login_dict), timeout=timeout,
                                verify=verify_ssl_cert)

        # raise an exception if the server didn't give the expected response
        if response.status_code != requests.codes.ok:
            response.raise_for_status()

        json_response = response.json()
        session_id = json_response['sessionId']

        # if login failed for any other reason,
        if not session_id:
            raise ValueError("Server responded successfully, but response did not include the "
                             "required session id")

        logger.info('Successfully logged into ICE at %s' % base_url)

        return SessionAuth(session_id, session)
